/* -- 求n!的非零末位数 -- */
int ff[10]={1,1,2,6,4,4,4,8,4,6};
int fact_last_digit(int n)
{
	if(n<5) return ff[n];
	int x=(ff[n%10]*6)%10;
	for(int i=1;i<=(n/5)%4;i++)
		if(x==6||x==2) x=(x+10)/2;
		else x/=2;
	return (fact_last_digit(n/5)*x)%10;

}
/*
-- 求n!的非零末位数 --
首先考虑某一个N!(N < 10)，我们先将所有5的倍数提出来，用1代替原来5的倍数的位置。
由于5的倍数全被提走了，所以这样就不会出现尾数0了。我们先把0..9的阶乘的尾数列出来
（注意，5的倍数的位置上是1），可以得到
table[0..9] = (1, 1, 2, 6, 4, 4, 4, 8, 4, 6)。
对于N < 5，直接输出table[N]即可；对于N > = 5，由于提出了一个5，因此需要一个2与之
配成10，即将尾数除以2。注意到除了0 !和1!，阶乘的最后一个非零数字必为偶数
（显然，因为在N!的质因数里2的个数要多），所以有一个很特别的除法规律：
2 / 2 = 6，4 / 2 = 2，6 / 2 = 8，8 / 2 = 4。
这样我们就可以得到如下式子:
           table[N]
F(N) = ------------ (0 <= N < 10)
           2^([N/5])

再考虑复杂的。考虑某一个N!(N >= 10)，我们先将所有5的倍数提出来，用1代替原来5的倍数
的位置。由于5的倍数全被提走了，所以这样就不会出现尾数0了。我们观察一下剩下的数的
乘积的尾数，通过table表，我们发现这10个数的乘积的尾数是6，6 * 6的尾数还是6，因此
我们将剩下的数每10个分成一组，则剩下的数的乘积的尾数只与最后一组的情况有关，即与
N的最后一位数字有关。由于我们把5的倍数提出来了，N!中一次可以提出[N/5]个5的倍数，
有多少个5，就需要有多少个2与之配成10，所以有多少个5，最后就要除以多少个2。注意
到除2的结果变化是4个一循环，因此如果有A个5，只需要除(A MOD 4)次2就可以了。A MOD 4只
与A的最后两位数有关，很好求算。剩下的5的倍数，由于5已经全部处理掉了，就变成[N/5]!。
于是，我们可以得到一个递归关系：
             F([N/5]) * table[N的尾数] * 6
F(N) = ---------------------------------------- (N > 10)
                    2^([N/5] MOD 4)

这样我们就得到了一个O(log5(N))的算法
*/